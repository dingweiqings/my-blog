{"meta":{"title":"猫猫攻城狮的博客","subtitle":"","description":"","author":"KurtDing","url":"https://dingweiqings.github.io/dingweiqings.github.io","root":"/dingweiqings.github.io/"},"pages":[{"title":"about","date":"2023-06-14T06:24:25.000Z","updated":"2023-06-14T06:25:24.485Z","comments":true,"path":"about/index.html","permalink":"https://dingweiqings.github.io/dingweiqings.github.io/about/index.html","excerpt":"","text":"关于我我是程序员一枚，对底层很感兴趣，目前已学习linux,数据库 github地址https://github.com/dingweiqings"}],"posts":[{"title":"c++11新特性","slug":"C++/C++新特性","date":"2023-01-17T11:40:56.000Z","updated":"2023-01-17T11:40:56.180Z","comments":true,"path":"/2023/01/17/C++/C++新特性/","link":"","permalink":"https://dingweiqings.github.io/dingweiqings.github.io/2023/01/17/C++/C++%E6%96%B0%E7%89%B9%E6%80%A7/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"多重继承","slug":"C++/多重继承","date":"2023-01-17T11:40:28.000Z","updated":"2023-01-17T11:40:28.157Z","comments":true,"path":"/2023/01/17/C++/多重继承/","link":"","permalink":"https://dingweiqings.github.io/dingweiqings.github.io/2023/01/17/C++/%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"LSM树","slug":"数据结构/LSM树","date":"2022-11-22T02:14:57.000Z","updated":"2023-06-14T04:49:19.099Z","comments":true,"path":"/2022/11/22/数据结构/LSM树/","link":"","permalink":"https://dingweiqings.github.io/dingweiqings.github.io/2022/11/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/LSM%E6%A0%91/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"决策树","slug":"算法/决策树","date":"2022-11-22T02:14:36.000Z","updated":"2023-06-14T04:49:43.699Z","comments":true,"path":"/2022/11/22/算法/决策树/","link":"","permalink":"https://dingweiqings.github.io/dingweiqings.github.io/2022/11/22/%E7%AE%97%E6%B3%95/%E5%86%B3%E7%AD%96%E6%A0%91/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"RSA","slug":"算法/RSA","date":"2022-11-22T02:12:38.000Z","updated":"2023-06-14T04:50:13.131Z","comments":true,"path":"/2022/11/22/算法/RSA/","link":"","permalink":"https://dingweiqings.github.io/dingweiqings.github.io/2022/11/22/%E7%AE%97%E6%B3%95/RSA/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"线性同余","slug":"算法/线性同余","date":"2022-11-22T02:12:32.000Z","updated":"2023-06-14T04:50:07.427Z","comments":true,"path":"/2022/11/22/算法/线性同余/","link":"","permalink":"https://dingweiqings.github.io/dingweiqings.github.io/2022/11/22/%E7%AE%97%E6%B3%95/%E7%BA%BF%E6%80%A7%E5%90%8C%E4%BD%99/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"素数","slug":"算法/素数","date":"2022-11-22T02:12:14.000Z","updated":"2023-06-14T04:49:50.563Z","comments":true,"path":"/2022/11/22/算法/素数/","link":"","permalink":"https://dingweiqings.github.io/dingweiqings.github.io/2022/11/22/%E7%AE%97%E6%B3%95/%E7%B4%A0%E6%95%B0/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"哈夫曼编码","slug":"算法/哈夫曼编码","date":"2022-11-22T02:11:54.000Z","updated":"2023-06-14T04:49:58.587Z","comments":true,"path":"/2022/11/22/算法/哈夫曼编码/","link":"","permalink":"https://dingweiqings.github.io/dingweiqings.github.io/2022/11/22/%E7%AE%97%E6%B3%95/%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"大数运算","slug":"算法/大数运算","date":"2022-11-22T02:11:46.000Z","updated":"2023-06-14T04:49:34.051Z","comments":true,"path":"/2022/11/22/算法/大数运算/","link":"","permalink":"https://dingweiqings.github.io/dingweiqings.github.io/2022/11/22/%E7%AE%97%E6%B3%95/%E5%A4%A7%E6%95%B0%E8%BF%90%E7%AE%97/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"移位","slug":"C++/左移右移位运算","date":"2022-11-22T01:54:30.000Z","updated":"2023-06-14T04:48:47.986Z","comments":true,"path":"/2022/11/22/C++/左移右移位运算/","link":"","permalink":"https://dingweiqings.github.io/dingweiqings.github.io/2022/11/22/C++/%E5%B7%A6%E7%A7%BB%E5%8F%B3%E7%A7%BB%E4%BD%8D%E8%BF%90%E7%AE%97/","excerpt":"","text":"正数负数位移偏移量是正数，负数位运算","categories":[],"tags":[]},{"title":"数据类型和运算","slug":"C++/数据类型和运算","date":"2022-11-22T01:54:04.000Z","updated":"2023-06-14T04:49:01.690Z","comments":true,"path":"/2022/11/22/C++/数据类型和运算/","link":"","permalink":"https://dingweiqings.github.io/dingweiqings.github.io/2022/11/22/C++/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E8%BF%90%E7%AE%97/","excerpt":"","text":"数据类型和大小short 16位int 等于字长，64位机上一般是32位long 可以和int一样，也可以和long long 一样，不小于intlong long 64位 float 32位double 64位long double 128位甚至更多 正数和负数的整除和取模","categories":[],"tags":[]},{"title":"线程池","slug":"java/线程池","date":"2022-11-22T01:49:13.000Z","updated":"2022-11-23T02:36:21.935Z","comments":true,"path":"/2022/11/22/java/线程池/","link":"","permalink":"https://dingweiqings.github.io/dingweiqings.github.io/2022/11/22/java/%E7%BA%BF%E7%A8%8B%E6%B1%A0/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"jvm-gc","slug":"java/jvm-gc","date":"2022-11-22T01:41:49.000Z","updated":"2022-11-23T02:36:21.935Z","comments":true,"path":"/2022/11/22/java/jvm-gc/","link":"","permalink":"https://dingweiqings.github.io/dingweiqings.github.io/2022/11/22/java/jvm-gc/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"TreeMap","slug":"java/TreeMap","date":"2022-11-22T01:41:23.000Z","updated":"2022-11-23T02:36:21.935Z","comments":true,"path":"/2022/11/22/java/TreeMap/","link":"","permalink":"https://dingweiqings.github.io/dingweiqings.github.io/2022/11/22/java/TreeMap/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"TransferQueue","slug":"java/TransferQueue","date":"2022-11-22T01:41:08.000Z","updated":"2022-11-23T02:36:21.935Z","comments":true,"path":"/2022/11/22/java/TransferQueue/","link":"","permalink":"https://dingweiqings.github.io/dingweiqings.github.io/2022/11/22/java/TransferQueue/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"ConcurrentHashMap","slug":"java/ConcurrentHashMap","date":"2022-11-22T01:40:46.000Z","updated":"2022-11-23T02:36:21.935Z","comments":true,"path":"/2022/11/22/java/ConcurrentHashMap/","link":"","permalink":"https://dingweiqings.github.io/dingweiqings.github.io/2022/11/22/java/ConcurrentHashMap/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"HashMap","slug":"java/HashMap","date":"2022-11-22T01:40:38.000Z","updated":"2022-11-23T02:36:21.935Z","comments":true,"path":"/2022/11/22/java/HashMap/","link":"","permalink":"https://dingweiqings.github.io/dingweiqings.github.io/2022/11/22/java/HashMap/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"算法/crc学习","slug":"算法/crc学习","date":"2022-11-21T03:26:27.000Z","updated":"2023-06-14T04:28:50.655Z","comments":true,"path":"/2022/11/21/算法/crc学习/","link":"","permalink":"https://dingweiqings.github.io/dingweiqings.github.io/2022/11/21/%E7%AE%97%E6%B3%95/crc%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"奇偶校验磁盘冗余阵列数学原理多项式代数和多项式除法高等代数中的多项式代数知识 12M/N=Q...R 这里容易得到，R会比N幂次要低，就和整数除法m&#x2F;n&#x3D;q..r ，0&lt;&#x3D;r&lt;n 一样 除法规则-竖式除法每次消去余数最高项，直到余数最高次项小于除数!除法 大牛在1961年发布的论文 https://en.wikipedia.org/wiki/W._Wesley_Peterson 算法 朴素的竖式多项式除法的翻译这里主要思路是用商消去最高位，然后在输入的数组上减去商*生成多项式，因此余数也是保存在输入的被除多项式位置 1234567891011121314151617181920212223242526272829303132int divide( double num[], int nlen, double den[], int dlen, double quotient[], int *qlen )&#123; int n, d, q; // The lengths are one more than the last index; decrement them // here so the call is less confusing nlen--; dlen--; q = 0; // when n &gt; dlen, the result is no longer a polynomial // (e.g. trying to divide x by x^2 for ( n = nlen; n &gt;= dlen; n-- ) &#123; // First, divide the nth element of numerator with the last element // of the denominator quotient[ n - dlen ] = num[ n ] / den[ dlen ]; q++; // Now, multiply each element of the denominator by each // corresponding element of the numerator and subtract the // result for ( d = dlen; d &gt;= 0; d-- ) &#123; num[ n - ( dlen - d ) ] -= den[ d ] * quotient[ n - dlen ]; //采用模2除法，需要修改成这行代码 num[ n - ( denlen - d ) ] = fabs( num[ n - ( denlen - d ) ] ); &#125; &#125; *qlen = q; return ( nlen - *qlen + 1 );&#125; 使用异或来计算这里比较难理解，让我想了很久，还是基于竖式除法的思路，从竖式除法我们可以发现，32位的生成多项式最高位可以不存储，因为每次都是消去最高项；可以用一个32位int来保存余数，长度小于32位的二进制序列余数就是它自己，因此需要在右端补上32位；从竖式除法中我们可以发现，做减法的次数等于被除数长度-除数长度+1； 123456789101112131415161718192021222324unsigned long int compute_crc( unsigned long input, int len, unsigned long divisor )&#123; //要做被除数长度-除数长度+1=24+32-33+1=24 while ( len-- ) &#123; //如果最高位是1，那么这位是要被消去，余数等于剩下的和除数异或；如果最高位是0，我们发现最高位死0，实际上是 //商为0，和全0异或等于它自己，等效于直接左移 input = ( input &amp; 0x80000000 ) ? divisor ^ ( input &lt;&lt; 1 ) : ( input &lt;&lt; 1 ); &#125; //余数存储在32位，这里实际上等价于竖式多项式的低32位；因为运算过程中，余数始终保存在input位置 return input;&#125;... unsigned long int crc32_divisor = 0x04C11DB7; //下面的input按ABC实际上的值字节做了反转，多项式是低字节在低位，为了位对齐 // 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, // C // 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, // B // 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 // A unsigned long int input = 0x8242C200; // ABC; backwards &amp; left aligned printf( &quot;%lx\\n&quot;, compute_crc( input, 24, crc32_divisor ); // 5A5B433A 常见组件关于crc的实现 mariadb中用的是查表，或者使用cpu的sse来计算 zlib 引用 这是大牛的ppt讲解，https://pdfs.semanticscholar.org/44c1/4780d58015f8411fb85efa58a4aa3747a6ad.pdf 论文原版https://apt.cs.manchester.ac.uk/ftp/pub/apt/papers/Peterson-Brown_61.pdf https://www.shuxuele.com/algebra/polynomials-division-long.html 模2除法https://blog.csdn.net/weixin_39450145/article/details/83987836 gcc中crc32的实现 mysql中crc32的实现 crc32 校验和 https://commandlinefanatic.com/cgi-bin/showarticle.cgi?article=art008 常用的除数多项式 github doc https://github.com/komrad36/CRC","categories":[],"tags":[]}],"categories":[],"tags":[]}