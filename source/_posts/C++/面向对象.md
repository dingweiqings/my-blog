---
title: 面向对象
date: 2023-01-17 19:40:28
tags: C++
categories: C++
---
# 面向对象的软件设计方式
大型软件工程中是根据需求中的实体来建模的,对象往往代表了这些实体。具有这些实体的属性，并以提供和其他对象交互的函数。有以下的优势：
1. 逻辑容易设计和理解
2. 可以提高代码功能逻辑的复用
3. 代码上高内聚低耦合，面向接口依赖
# 面向对象的基本概念和模式
类：类是描述一类对象的特征和提供特定功能的代码实体，同时也是实例的模板，实例以类为模板
实例: 具体的一个对象，具有实例变量，是类的一个具体化。
类有静态属性和动态属性之分，静态属性是所有实例共享的，动态属性是每个实例特有的，又称实例属性
## 举个例子，以人为例
```
usingnamespace std::string;
class Person{
    private:
      int age;
      string name;
      string work;
    public:  
      static string motherland;
    private:
      string doWork(){
        std::cout>>"我在做xxxjob";
      }  
    public:
      string buy(string car){
        std::cout>>"买了">>car;
      }  
};
Person::motherland = "中国";
Person zhangsan = Person(10,"张三","学生");
Person lisi = Person(25,"李四","程序员");
```
来验证前面的理论，类是实体的建模，成员是对实体属性的抽象。两个实例zhangsan和lisi是类Person的具体化，动态属性的值各不相同。但都有一个共享的静态变量。类有特定功能的函数或者说有特定行为的函数，这些函数用来和其他对象交互.
## 进一步的概念
经过上面的例子，就可以归纳出在代码实体上的概念：
- 成员变量,类的属性
- 方法，类的特定行为的函数
- 成员变量和方法的权限
- 普通函数，和c中函数类似，不在类的代码块内部
- 构造函数和析构函数
- 继承，对象的树级关系
- 虚函数，子类可以重写的方法，编译器用virtual关键字来识别
- 纯虚函数，用来定义接口，带有纯虚函数的不能实例化,编译器用virtual关键字+方法体=0来定义
- 抽象基类,用做接口定义,包含纯虚函数的类是抽象基类，不能实例化，只能被继承，实例化成他的子类
### 下面介绍构造函数和析构函数
#### 默认构造函数和无参构造函数
默认构造函数是创建对象时默认调用的,如果没有声明，则编译器会按照一定条件来默认创建一个无参的构造函数，当然自己也可以声明无参的。自己声明了，编译器则不会再创建。**编译器创建的构造函数并不会赋初始值**。编译器的创建策略主要是
1. 有非基本类型的成员(自定义类型或者string类型),并且这些成员本身有默认构造函数。这种情况是如果只有基本类型在拷贝对象时，直接拷贝内存块即可
2. 有虚函数和虚继承，这种情况是需要虚函数表
3. 继承的父类有默认构造函数
这里推荐一个网站，可以用来查看编译后的汇编代码。https://godbolt.org/
引用1中的结论我是验证过的，在gcc13.2上。记住要加-O0(减号大o后面跟个优化等级)才可以得到结果

- 如果自己只定义了默认构造函数，编译器是否会生成拷贝/赋值/移动构造函数？
如果程序中有用到对象拷贝赋值则会生成并调用默认的构造函数，没有用到则不会生成
- 如果只定义了拷贝构造函数，还会生成默认构造函数吗？
这种不会，编译会报错
#### 析构函数
在释放对象时，编译调用的函数。如果是用来继承的类，必须声明为虚函数
#### 父子类的构造函数和析构函数顺序
构造：先基类，再子类
析构：先子类，再基类
对上面继承时析构函数需要声明为虚函数做些说明，因为虚函数再调用时才会根据运行时状态，调用子类对象的析构函数。编译器又会自动释放基类，从而可以完整的释放这条继承链上的所有对象。不是虚函数的话，会直接调用基类的析构函数，发生**内存泄露**
#### 拷贝构造函数
形如下面的code
```
//调用拷贝构造生成对象
A a ;
A b = A(a);
//函数返回值
A doSomeWork(){
  A work;
  ...
  return work;
}

//函数参数
void doSomeWork(A other){
  ...
}
```
拷贝构造是一定会生成新对象的，可能是临时的，过一会被删除。这也解释了为啥函数参数推荐使用引用或者指针，避免了重复创建临时对象

#### 赋值运算符
形如下面的code
```
A a;
B b;
C c;
c=b=a;
```
赋值号左右两边都是已经存在的对象，不会产生新对象

#### 移动构造函数
这个函数还是为了减少内存拷贝带来的特性。在编程中，有些类中会包含大的成员数组，或者大的成员变量。如果在拷贝赋值时可以直接将这个大的成员
直接移动给目标对象，可以减少很多拷贝开销。语义上理解很像是移动或者所有权转移。那怎么去实现他呢？需要一种标志来表示程序员啥时候可以使用移动语义，现在的引用是无法转移的。于是，那些C++大牛们提出了一个另外一种引用，当参数中以这种形式的引用出现时，编译器就会按照移动语义来实现。
一般文献中会称为右值引用,就可以理解为一种引用，不过是用来标志支持移动语义的。左值和右值可以相互转换
```
A (A&& other){
  array  = other.array; //移动
  other.array = nullptr;
}
```

#### 移动运算符
和上面类似的，运算符两边都是已经存在的对象，并且是移动语义


**注意** 拷贝构造/拷贝赋值与移动构造和移动赋值如果自己提供了其中一个，则编译不会提供另一个。因为只要有一种就都可以编译通过。可通过=default来声明


前面的测试代码见https://github.com/dingweiqings/study/tree/master/cpp_study/src/construct
# C++的对象模型


## 虚函数表


## 多重继承




# 引用
1. gcc生成默认构造器的策略
https://blog.csdn.net/qiuguolu1108/article/details/114797246
2. gcc生成拷贝构造和默认构造的策略
https://blog.csdn.net/shltsh/article/details/45959271